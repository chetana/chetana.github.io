<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Untitled :: Java Docs</title>
    <meta name="generator" content="Antora 2.3.4">
    <link rel="stylesheet" href="../../../_/css/site.css">
    <script>var uiRootPath = '../../../_'</script>
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="../../..">Java Docs</a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="#">Home</a>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Products</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Product A</a>
            <a class="navbar-item" href="#">Product B</a>
            <a class="navbar-item" href="#">Product C</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Services</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Service A</a>
            <a class="navbar-item" href="#">Service B</a>
            <a class="navbar-item" href="#">Service C</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Resources</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Resource A</a>
            <a class="navbar-item" href="#">Resource B</a>
            <a class="navbar-item" href="#">Resource C</a>
          </div>
        </div>
        <div class="navbar-item">
          <span class="control">
            <a class="button is-primary" href="#">Download</a>
          </span>
        </div>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="java" data-version="1.0">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../index.html">Java</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">À propos de Java</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../java-features.html">Caractéristiques</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../java-history.html">Historique</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../java-use-cases.html">Domaines d&#8217;application</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../java-editions.html">Éditions</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../java-evolution-support.html">Évolution et Support des différentes versions</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../java-versions.html">Versions</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../java-resources.html">Ressources</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">How To</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../how-to/java-installation.html">Install Java</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../how-to/java-command-line.html">Command Line</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Bases de Java</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../basics/java-application-basics-concepts.html">Concepts basiques d&#8217;une application Java</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../basics/java-keywords.html">Mots-clés Java</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Types</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../basics/types/java-primitive-types.html">Types primitifs</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../basics/types/java-object-types.html">Types objets</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../basics/types/java-operators.html">Opérateurs</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../basics/types/java-arrays.html">Tableaux</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../basics/types/java-strings.html">Strings</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../basics/types/java-enums.html">Enums</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../basics/types/java-big-decimal.html">Big Decimal</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../basics/oop/java-core-principles.html">Programmation Orientée Objet</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../basics/oop/java-access-modifiers.html">Modificateurs d&#8217;accès</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../basics/oop/java-class-members.html">Classes, Variables et Méthodes</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../basics/oop/java-pass-by-value.html">Passage des paramètres par valeur</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../basics/oop/java-overloading.html">Overloading</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../basics/oop/java-overriding.html">Overriding</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../basics/oop/java-constructors.html">Constructeurs</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../basics/oop/java-data-encapsulation.html">Encapsulation des données</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="#oop/java-object-composition.adoc">Composition objet</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../basics/oop/java-inheritance.html">Héritage</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../basics/oop/java-abstract.html">Classes et Méthode Abstraites</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../basics/oop/java-interface.html">Interface</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../basics/oop/java-polymorphism.html">Polymorphisme</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../basics/oop/java-object-methods.html">La classe Object</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Exceptions</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../basics/exceptions/java-reliable-program.html">Fiabilité d&#8217;une application Java</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../basics/exceptions/java-exceptions.html">Gestion des erreurs</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../basics/exceptions/java-try-catch.html">Patterns try-catch</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Java</span>
    <span class="version">1.0</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <a class="title" href="../index.html">Java</a>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../index.html">1.0</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
<nav class="breadcrumbs" aria-label="breadcrumbs">
</nav>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<div class="sect1">
<h2 id="_concurrency"><a class="anchor" href="#_concurrency"></a>Concurrency</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_terminologie"><a class="anchor" href="#_terminologie"></a>Terminologie</h3>
<div class="ulist">
<ul>
<li>
<p>Programmation Concurrente : programmer des applications qui font plusieurs choses en même temps
(qu&#8217;est ce que ca signife en même temps pour un CPU)
<a href="https://www.youtube.com/watch?v=m2GPdA6esUU&amp;list=PLzzeuFUy_CnhnuPvDhSLJRRAaqi9dsLjN&amp;index=1" class="bare">https://www.youtube.com/watch?v=m2GPdA6esUU&amp;list=PLzzeuFUy_CnhnuPvDhSLJRRAaqi9dsLjN&amp;index=1</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Ex: 4 taches
1) Word
2) Correcteur ortho
3) Sauvegarde auto
4) Notification de mail</p>
</div>
<div class="paragraph">
<p>occupation de mon microprocesseur sur une echelle de temps (cf image)
- une petite tranche de temps pour la tache 1
- une petite tranche de temps pour la tache 2 etc</p>
</div>
<div class="paragraph">
<p>au niveau du CPU, les taches s echelonnenet dans le temps mais ne se font pas exactement en emem temps. en premiere approche on dira qu un CPU fait une tache a la fois.</p>
</div>
<div class="paragraph">
<p>Ce qui me donne l impression que ces taches se font en meme temps, c est l echelle de temps. les taches s executent en quelques millisecondes mais l utilisateur percoit ca de facon quasi instantanee
&#8658; le temps du CPU est partage entre les differentes taches et a chaque instant j ai une chose qui s&#8217;execute a un instant. &#8658; rien ne s execute rigoureusement en meme temps</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Tâche : "sauvegarder un doc", "correcteur orthographique", "envoyer un mail"</p>
</li>
<li>
<p>Thread :</p>
<div class="ulist">
<ul>
<li>
<p>ressource gérée par l&#8217;OS</p>
</li>
<li>
<p>prendre en charge des tâches</p>
</li>
</ul>
</div>
</li>
<li>
<p>Thread Scheduler : chef d&#8217;orchestre qui va répartir la ressource en temps CPU entre les différentes tâches à exécuter</p>
<div class="ulist">
<ul>
<li>
<p>Quelles sont les raisons pour que le scheduler decide de passer a une autre tâche ?</p>
<div class="ulist">
<ul>
<li>
<p>1) equilibrage entre les tâches : meme si la tâche a pas termine son travail, le thread scheduler decide de donner le temps CPU a une autre</p>
</li>
<li>
<p>2) tâche en attente : elle est sur le temps CPU mais ne fait rien car elle attend des donnees (en provenance du reseau ou du disque ou encore de la memeoire qui sont des ressources lentes)
ex: sauvegarder le doc requiert d ecrire sur le disque, en attendant la reponse du disque, le CPU va dire a cette tache qu on passe a une autre</p>
</li>
<li>
<p>3) la synchronization</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Méthode main = tâche qui est exécutée dans un thread appelé le <strong>main thread</strong></p>
</div>
</div>
<div class="sect2">
<h3 id="_modélisation_dune_tâche_et_dun_thread"><a class="anchor" href="#_modélisation_dune_tâche_et_dun_thread"></a>Modélisation d&#8217;une tâche et d&#8217;un thread</h3>
<div class="sect3">
<h4 id="_runnable"><a class="anchor" href="#_runnable"></a>Runnable</h4>
<div class="paragraph">
<p>interface fonctionnelle qui modélise une tâche
void run();</p>
</div>
</div>
<div class="sect3">
<h4 id="_thread"><a class="anchor" href="#_thread"></a>Thread</h4>
<div class="ulist">
<ul>
<li>
<p>permet de créer de nouveaux threads, de confier des taches de type runnable dans les threads et de les executer</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Runnable task = () &#8594; System.out.println("Hello world!");
task.run(); // ici on exécute la tâche dans le thread courant</p>
</div>
<div class="paragraph">
<p>Thread t = new Thread(task);
t.start(); // start() va appeler la méthode run() de task dans un autre thread</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_thread_daemon"><a class="anchor" href="#_thread_daemon"></a>Thread Daemon</h3>
<div class="paragraph">
<p>On démarre un nouveau thread qui s&#8217;éteint après avoir fini sa tâche.
Dans notre exemple, le thread main s&#8217;eteint apres avoir fini sa tache apres avoir appele t.start().</p>
</div>
<div class="paragraph">
<p>Quand le thread main s&#8217;éteint, la question qui est posée par la JVM est "est ce que je continue a m&#8217;executer ou quitter"?</p>
</div>
<div class="paragraph">
<p><strong>Elle decide de s&#8217;arreter de s&#8217;executer s&#8217;il n&#8217;y a plus aucun thread de type "daemon" en fonctionnement</strong></p>
</div>
<div class="paragraph">
<p>Lorsqu&#8217;on démarre la JVM il y a tout un tas de threads qui demarrent en meme temps que le thread main par exemple le thread qui s occupe du GC et lui ne bloque pas la femreture de la JVM car il a un type particulier = "daemon"</p>
</div>
<div class="paragraph">
<p>daemon = propriété de la classe Thread (setDaemon(), isDaemon())
Ne bloque pas la fermeture de la JVM</p>
</div>
<div class="paragraph">
<p>Runnable task = () &#8594; sout(Thread.currentThread().getName());
task.run();</p>
</div>
</div>
<div class="sect2">
<h3 id="_notion_de_race_condition_concurrence_daccès_sur_les_données"><a class="anchor" href="#_notion_de_race_condition_concurrence_daccès_sur_les_données"></a>Notion de race condition = concurrence d&#8217;accès sur les données</h3>
<div class="paragraph">
<p>Prenons comme exemple la premiere implementation du pattern Singleton.</p>
</div>
<div class="paragraph">
<p>public class Service {
    private static Service service;
    private Service() { }
    public static Service getInstance() {
        if (service == null) {
            service = new Service();
        }
        return service;
    }
}</p>
</div>
<div class="paragraph">
<p>Cette implémentation ne fonctionne pas à cause de la notion de race condition.</p>
</div>
<div class="paragraph">
<p>Prenons 2 threads pour illustrer. T1 commence à s&#8217;executer et s&#8217;arrete juste avant de pouvoir faire le new Service() car le thread scheduler passe la main a T2. Ce dernier instancie un nouveau service puis la main est repassee a T1 qui continue alors sa tache et instancie un service.</p>
</div>
<div class="paragraph">
<p>PB1 : on voulait une seule instance, on se retrouve avec 2.
PB2 : l&#8217;instance du service que reference T2 n&#8217;est plus l&#8217;instance qu il avait mais celle de T1.</p>
</div>
<div class="paragraph">
<p>PB racine : concurrence d&#8217;accès ou race condition (j&#8217;ai 2 threads T1 et T2 qui se font la course a savoir celui qui va gagner pour instancier la variable service)
<strong>Quand 2 threads peuvent LIRE et ECRIRE une meme variable en meme temps</strong></p>
</div>
<div class="paragraph">
<p>dans l&#8217;exemple le problème vient des lignes qui est le moment où on fait le null check et le moment où l&#8217;objet créé est copié dans le champ service, le thread scheduler a moyen d&#8217;interrompre l&#8217;exécution du thread en cours.
if (service == null) {
    service = new Service();
}
return service;</p>
</div>
<div class="paragraph">
<p>sur certaines parties de mon code je peux empecher mon thread scheduler d imterrompren un thread. il peut l interrompre mais tant que le thread interrompu est dans le bloc de code, aucun autre thread ne peut entrer dans ce bloc de code.</p>
</div>
<div class="paragraph">
<p>synchronized {
    if (service == null) {
        service = new Service();
    }
    return service;
}</p>
</div>
<div class="paragraph">
<p>Synchroniser un bloc de code en Java = empecher quand un thread est en train d executer ce bloc de code qu un autre thread puisse venir a l interieur</p>
</div>
<div class="sect3">
<h4 id="_comment_marche_la_synchronization_en_java"><a class="anchor" href="#_comment_marche_la_synchronization_en_java"></a>Comment marche la synchronization en Java ?</h4>
<div class="paragraph">
<p>Object lock = new Object(); // verrou
synchronized (lock) {
 // bloc de code
}</p>
</div>
<div class="paragraph">
<p>Chaque objet a une clé (de la classe Object).
Lorsqu&#8217;un thread T1 veut exécuter ce bloc de code symchronisé, il prend la clé de lock et commence ses tâches.
Si le thread scheduler arrête T1 (toujours dans le bloc de code synchronizé) pour laisser place à T2 et que celui-ci veut exécuter le bloc de code, il va demander la clé à lock.
Or, lock n&#8217;a pas la clé donc T2 est en attente. &#8658; il va être placé dans une file d&#8217;attente la WAIT_LIST
Le thread scheduler dit ok tu es bloqué et va arrêter T2 pour laisser place à T1 ou TX.
Une fois sorti du bloc de code synchronisé, T1 rend la clé à lock.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
il faut bien maitriser l&#8217;objet lock qui va servir de porteur de clé, savoir comment l&#8217;objet est partagé et savoir quel est cet objet si on utilse des objets implicites
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>public synchronized void increment() { }</p>
</div>
<div class="paragraph">
<p>public synchronized static void getInstance() {}</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
facon "explicite" preferee car c&#8217;est la seule facon qui permet de cacher l&#8217;objet qui va servir a la synchronization. On ne veut pas exposer l&#8217;objet qui sert a la synchro car on a des risques de creer des deadlocks
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_mecanisme_reentrant"><a class="anchor" href="#_mecanisme_reentrant"></a>Mecanisme reentrant</h4>
<div class="paragraph">
<p>La synchronization en Java est un mecanisme reentrant = quand je possede deja une cle je peux entrer dans un bloc synchro sur la meme cle que je possede</p>
</div>
<div class="paragraph">
<p>public synchronized Service getInstance() {
    if (isNull(service)) { }
}</p>
</div>
<div class="paragraph">
<p>public synchronized boolean isNull(Service s) { }</p>
</div>
<div class="paragraph">
<p>si un thread appelle isNull() il demande son moniteur (clé) or le thread est deja en possession de cette clé car il est dans getInstance()
&#8658; cas d&#8217;exception qui autorise le thread qui execute getService() a executer isNull() car ce thread possede deja le moniteur necessaire a l execution de isNull()</p>
</div>
</div>
<div class="sect3">
<h4 id="_synchronisation_de_plusieurs_blocs_de_code_avec_la_même_clé"><a class="anchor" href="#_synchronisation_de_plusieurs_blocs_de_code_avec_la_même_clé"></a>Synchronisation de plusieurs blocs de code avec la même clé</h4>
<div class="paragraph">
<p>public class User {
    // lock = this
    synchronized String getName() {}</p>
</div>
<div class="literalblock">
<div class="content">
<pre>    // lock = this
    synchronized int getAge() {}
}</pre>
</div>
</div>
<div class="paragraph">
<p>Si T1 execute getName() il va avoir la cle
T2 ne pourra pas executer getName() ET il ne pourra pas non plus executer getAge() !!!</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
bien reflechir lorsqu on fait des synchronized directement places sur les blocs de code &#8658; ces blocs de code vont devenir <strong>exclusifs</strong> des uns des autres! Est-ce vraiment ce que l&#8217;on veut faire dans cette application ?
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_synchronisation_avec_une_même_clé_dinstance_ou_une_clé_statique"><a class="anchor" href="#_synchronisation_avec_une_même_clé_dinstance_ou_une_clé_statique"></a>Synchronisation avec une même clé d&#8217;instance ou une clé statique</h4>
<div class="paragraph">
<p>public class User {
    Object lock = new Object();</p>
</div>
<div class="literalblock">
<div class="content">
<pre>// lock = lock
public String getName() {
    synchronized(lock) {}
}</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>    // lock = lock
    public int getAge() {
        synchronized(lock) {}
    }
}</pre>
</div>
</div>
<div class="paragraph">
<p>Si T1 a une instance de User nommée U1 et qu&#8217;il appelle getName(), il aura la clé de U1.lock donc on ne pourra pas appeler de façon concurrente getAge() MAIS si T2 a une instance de User nommée U2 et qu&#8217;il appelle getName(), c&#8217;est possible car il aura la clé U2.lock. Si on veut empécher ça, il faut que l&#8217;objet lock soit partagé par toutes les instances en le rendant static (static Object lock = new Object();)</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
cela dépend bien sûr de ce que l&#8217;on souhaite faire dans l&#8217;application.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_deadlock"><a class="anchor" href="#_deadlock"></a>Deadlock</h4>
<div class="ulist">
<ul>
<li>
<p>Situation dans laquelle on est obligé de redémarrer l&#8217;application et donc créer une interruption de service !</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>public class User {
    lock1, lock2;</p>
</div>
<div class="literalblock">
<div class="content">
<pre>m1() {
    synchronized(lock1) {
        m2();
    }
}</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>m2() {
    synchronized(lock2) {
        m3();
    }
}</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>    m3() {
        synchronized(lock1) {}
    }
}</pre>
</div>
</div>
<div class="paragraph">
<p>T1 execute m1() &#8658; il a le lock1 L1
T2 execute m2() &#8658; il a le lock2 L2
Mais pour que T1 execute m2() &#8658; il se met en attente de L2 (WAIT T2 libère L2)
De même pour que T2 execute m3() &#8658; il se met en attente de L1 (WAIT T1 libère L1)
&#8658; on se retrouve dans une situation d&#8217;impasse, de blocage : <strong>2 threads qui s&#8217;attendent en possédant le moniteur que l&#8217;autre cherche à obtenir</strong></p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
lorsque l&#8217;on se retrouve dans cette situation, on n&#8217;a aucun moyen de faire sortir T1 et T2 de ces WAIT LIST pour essayer de les libérer, pas même avec des exceptions ! &#8658; redémarrer l&#8217;appli
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Comment éviter les situations de deadlock ?
Preferer la synchronization sur des membres prives des classes (permet de controler exactement qui peut utiliser l&#8217;objet grosso modo les methodes de la classe ce qui permet de mieux analyser les situations de synchro) que sur des objets exposes explicitiment (objets public) ou implicitement en creant des methodes synchronizees ou des methodes statiques synchronizees = exposer les objets qui nous servent a la syncrho et le fait de les exposer font que dautres parties de l appli vont pouvoir les utiliser ce qui augmente les prba d avoir des deadlock</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_pattern_producerconsumer"><a class="anchor" href="#_pattern_producerconsumer"></a>Pattern Producer/Consumer</h3>
<div class="paragraph">
<p>class Buffer {
    int[] buffer = &#8230;&#8203;
    int index = 0;</p>
</div>
<div class="literalblock">
<div class="content">
<pre>// il faut index &lt; taille du tableau
public void add(int index) {
    buffer[index] = index;
    index++;
}</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>    // il faut index &gt; 0
    public int remove() {
        int i = buffer[index];
        index--;
    }
}</pre>
</div>
</div>
<div class="paragraph">
<p>Soient 2 threads TProducer et TConsumer qui vont executer les methodes add() et remove().
Ces 2 methodes sont executees dans 2 threads differents. &#8658; les variables index et buffer sont soumises à une race condition = concurrence d accès car ils peuvent etre lus et ecrits de 2 threads différents</p>
</div>
<div class="paragraph">
<p>class Buffer {
    int[] buffer = &#8230;&#8203;
    int index = 0;</p>
</div>
<div class="literalblock">
<div class="content">
<pre>public void add(int index) {
    synchronized(l) {
        while(isFull(buffer)){}
        buffer[index] = index;
        index++;
    }
}</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>    // il faut index &gt; 0
    public int remove() {
        synchronized(l) {
            while(isEmpty(buffer)){}
            int i = buffer[index];
            index--;
        }
    }
}</pre>
</div>
</div>
<div class="paragraph">
<p>Cette approche simple et naive ne fonctionne pas. En effet, lorsque TProducer appelle add() et que le buffer est plein, il se trouve dans la boucle en attente que le TConsumer vienne vider le buffer. Or, pour que TConsumer execute remove() il a besoin de la clé déjà tenue par TProducer.
&#8658; Il faut un moyen de dire à TProducer d&#8217;attendre en rendant la clé pour que TConsumer l&#8217;utilise, fasse son action et notifie TProducer que le buffer a été vidé de quelques éléments</p>
</div>
<div class="paragraph">
<p>&#8658; Mécanisme WAIT/NOTIFY
dans notre exemple : je mets TProducer en mode WAIT jusqu&#8217;à ce que TConsumer fasse son action et appelle NOTIFY pour réveiller TProducer</p>
</div>
<div class="paragraph">
<p>class Buffer {
    int[] buffer = &#8230;&#8203;
    int index = 0;</p>
</div>
<div class="literalblock">
<div class="content">
<pre>public void add(int index) {
    synchronized(l) {
        while(isFull(buffer)){
            l.wait();
        }
        buffer[index] = index;
        index++;
        l.notify();
    }
}</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>    // il faut index &gt; 0
    public int remove() {
        synchronized(l) {
            while(isEmpty(buffer)){
                l.wait();
            }
            int i = buffer[index];
            index--;
            l.notify();
            // l.notifyAll(); // reveille l'integralite des threads dans la file d'attente
        }
    }
}</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>La méthode WAIT ne peut être appelée que sur un objet dont on possède le moniteur &#8658; il faut donc etre dans un bloc synchronise sur l&#8217;objet sur lequel on appelle wait</p>
</li>
<li>
<p>Le thread courant est mis en sommeil, il va cesser de s executer, il est mis dans une file d&#8217;attente differente de la file d attente qu il y a a l entree d un bloc synchronise</p>
</li>
<li>
<p>Le thread rend le moniteur de l&#8217;objet</p>
</li>
<li>
<p>La méthode NOTIFY() va prendre tous les threads de la WAIT LIST de l&#8217;objet lock (les threads qui ont appele l.wait()), la methode va en prendre un et le réveiller</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Ce pattern wait/notify est l&#8217;une des bonnes facons de resoudre le pb du pattern producer/consumer</p>
</div>
</div>
<div class="sect2">
<h3 id="_architecture_mutilcoeur"><a class="anchor" href="#_architecture_mutilcoeur"></a>Architecture mutilcoeur</h3>
<div class="ulist">
<ul>
<li>
<p>Les choses se passent de facon differente lorsque l&#8217;on ait sur un seul coeur ou alors plusieurs coeurs.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Dans le cas du singleton lors de la creation la premiere fois du service, lorsqu&#8217;on est sur multicoeurs, le thread scheduler va attendre d&#8217;abord un peu de voir si le moniteur necessaire au thread T2 est libere par T1 avant de le mettre en attente alors que sur un monocoeur, il l&#8217;aurait directement deja mis en attente car le moniteur n&#8217;aurait pas pu etre libere de toute facon.</p>
</div>
<div class="sect3">
<h4 id="_impact_de_la_lecture_synchronisée_du_singleton_sur_un_cpu_multicoeur"><a class="anchor" href="#_impact_de_la_lecture_synchronisée_du_singleton_sur_un_cpu_multicoeur"></a>Impact de la lecture synchronisée du Singleton sur un CPU multicoeur</h4>
<div class="paragraph">
<p>Imaginons que le service est instancie et que 2 threads veulent acceder a la variable. Vu que la lecture est synchronisee, T2 sera oblige d&#8217;attendre la fin de T1 &#8658; impossible de faire de la lecture en //
Si on a 32 coeurs, on sera oblige de mettre en attente 31 threads</p>
</div>
</div>
<div class="sect3">
<h4 id="_double_check_locking"><a class="anchor" href="#_double_check_locking"></a>Double Check Locking</h4>
<div class="paragraph">
<p>Solution apportée mais fausse bonne idée &#8658; BUG :
public Service getInstance() {
    // bloc non synchronise de lecture
    if (instance != null) {
        return instance;
    }</p>
</div>
<div class="literalblock">
<div class="content">
<pre>    synchronized(lock) {
        // on refait un check car le thread scheduler aurait pu m'interrompre entre la fin du bloc non synchronise et avant le debut du bloc synchronise
        if (instance == null) {
            instance = new Service();
        }
        return instance;
    }
}</pre>
</div>
</div>
<div class="paragraph">
<p>Ce pattern bugue car cela tient a la nature et a l architecture interne des processeurs multicoeurs.</p>
</div>
<div class="paragraph">
<p>Un coeur = une unite capable de faire des calculs en entier et en virugule flottante
jusqu&#8217;en 2005 : Monocoeur
à partir de 2005 : Multicoeur</p>
</div>
<div class="paragraph">
<p>4 coeurs physiques
8 coeurs virtuels hyper threades avec un meca cparticulier pour switcher le contexte d un thread t1 vers un thread t2 sur un coeur donne</p>
</div>
<div class="paragraph">
<p>Le multicoeur a un impact enorme sur le fonctionnement et les patterns de la programmation concurrente
La vitesse des processeurs
~90 : CPU connecte directement a la memoire RAM et on accede a cette memoire vive avec un delai d environ 70ns
Today : CPU plus connecte directement a cette memoire (~70ns)
le temps d acces a la memoire vive a assez peu evolue depuis
La difference c est que today les CPU sont capables de traiter les donnees à environ 1ns par donnée alors que ds les 90s la vitesse du CPu etait compatible directement avec celle de la memoire</p>
</div>
<div class="paragraph">
<p>On a un probleme d adaptation entre la vitesse a laquelle on peut sortir les donnees de la memoire centrale et la vitesse a laquelle il faut fournir des donnees a notre processeur pour qu il puisse calculer a vitesse maximale.
Si on a 4 coeurs il faudrait idealement fournir 4 donnees par nanoseconde alors que la RAM ne peut en produire qu&#8217;une seule tous les 70ns.</p>
</div>
<div class="paragraph">
<p>Comment ce probleme a ete traite ?
==== Organisation des caches mémoire dans les CPU
avec un empilement de caches  (cf image)
* 3 couches de cache (L1, L2, L3 qui est partagee entre les coeurs du processeur)</p>
</div>
<div class="paragraph">
<p>Coeurs + cache = a l interieur du silicium du CPU
CPU Connecte via un bus sur la carte mere des ordinateurs en general a la RAM avec un temps d&#8217;accès de 70ns</p>
</div>
<div class="paragraph">
<p>Au niveau de la quantite de memoire :
L3 - 8Mo (15ns)
L2 - 256ko (3ns)
L1 - 32ko (fournit des donnees a la vitesse de 1ns)
La taille de chaque cache diminue au fur et a mesure qu on se rapproche du processeur mais la vitesse a laquelle on peut acceder a chaque cache va augmenter grandement pour resoudre ce probleme d adaptation entre la memoire centrale et les coeurs du processeur</p>
</div>
<div class="paragraph">
<p>Lien Happens Before (cf image pour l exemple)
on a 2 threads,
T1 sur C2 qui fait i = 0 &#8658; cette variable i est creee dans la RAM (declaree dans la memoire centrale de la machine) et elle descend dans le cache de niveau 1 L1 du coeur C2
T2 sur C3 qui fait j = i+1 dans le cache L1 du coeur C3</p>
</div>
<div class="paragraph">
<p>La variable i vit dans 3 endroits differents : la RAM, le cache L1 de C2 et le cache L1 de C3. Comment le cache L1 du C3 sait que la valeur de i a été fixée à 0?</p>
</div>
<div class="paragraph">
<p>Visibilité : comment un thread "voit-il" les modifications effectuees dans un autre thread ?</p>
</div>
<div class="paragraph">
<p>&#8658; A l&#8217;interieur du langage Java, on a la notion de Happens - Before = un lien entre une ecriture et une lecture &#8658; <strong>la lecture a la garantie de retourner la valeur qui a ete ecrite juste avant dans la variable dont je m occupe</strong></p>
</div>
<div class="paragraph">
<p>dans l&#8217;exemple : j&#8217;ai l ecriture de la valeur 0 dans i et la lecture dans l&#8217;autre thread de la variable i incrementee de 1 puis le resultat ecrit dans j &#8658; ces 2 operations ont un lien HB : j&#8217;ai la garantie que j va correctement lire la valeur de i</p>
</div>
<div class="paragraph">
<p>Comment créer ce lien HB ?
Cette notion est definie dans la JLS : Java Language Specification
Un lien happens-before existe entre toute écriture synchronisée ou volatile
et toute
lecture synchronisée ou volatile qui suit</p>
</div>
<div class="paragraph">
<p>dans l&#8217;exemple, il faut que i=0 soit fait dans un bloc synchro et idem pour j = i+1</p>
</div>
<div class="paragraph">
<p>ex2:
on reprend le meme schema :
T1 (100 fois) public void increment() {
    synchronized(lock) {
        i++;
    }
}</p>
</div>
<div class="paragraph">
<p>T2 (10 fois) public void display() {
    synchronized(lock) {
        sout(i);
    }
}</p>
</div>
<div class="paragraph">
<p>si les blocs n etaient pas synchro &#8658; pas de lien HB, T2 aurait pu afficher dans les 10 fois
* soit 0 car il n&#8217;a vu aucune modif
* soit 1 fois 100 car il aura vu que la derniere
* soit des valeurs intermediaires car il en aura vu une partie et pas la fin</p>
</div>
<div class="paragraph">
<p>Au niveau de l&#8217;architecture avec les caches, les traitements qui se font au cache L1 de C2 et C3 localement tres rapides doivent obligatoirement passer par le cache L3 pour pouvoir dialoguer et echanger les infos updatees (a une vitesse 15 fois plus lente). Cet echange d info passe necesseraiment par le cache L3 pour que T2 sache que i a ete fixee a 0
&#8658; cette synchro a donc un cout de performance mais elle est necessaire pour avoir des variables a jour</p>
</div>
<div class="paragraph">
<p>Deuxième exemple de lien Happens Before au résultat aléatoire (cf image)
<a href="https://www.youtube.com/watch?v=JL7cVjcRJJU&amp;list=PLzzeuFUy_CnhnuPvDhSLJRRAaqi9dsLjN&amp;index=28" class="bare">https://www.youtube.com/watch?v=JL7cVjcRJJU&amp;list=PLzzeuFUy_CnhnuPvDhSLJRRAaqi9dsLjN&amp;index=28</a></p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_volatilite"><a class="anchor" href="#_volatilite"></a>volatilite</h3>
<div class="paragraph">
<p>une ecriture/lecture volatile = une ecriture/lecture sur un champ declare comme volatile
volatile int index 0; &#8658; HB s&#8217;applique
int i = 0;</p>
</div>
<div class="paragraph">
<p>volatile DIFFERENT DE synchonize cf le touilleur express</p>
</div>
<div class="paragraph">
<p>index;
synchronized(lock) {
    i;
}</p>
</div>
<div class="paragraph">
<p>index++ &#8658; index = index + 1; // j&#8217;ai une lecture etune ecriture qui se suivent
le thread scheduler peut decider d interrompre cette operation la entre la lecture incrementation d une part et l&#8217;ecriture d autre part</p>
</div>
<div class="paragraph">
<p>i++ &#8658; i = i+1; // le thread scheduler peut toujours interrompre l operation en cours entre la lecture/incremetnation d une part et d 'autre part l&#8217;inrementation MAIS il ne peut pas donner la main a un autre thread pour executer egalement une incrementation avant que l ecriture n ait lieu</p>
</div>
<div class="paragraph">
<p>Conclusion :
la volatilite donne la visibilite = les op de modification sont visibles d&#8217;un thread a l autre
la synchro ca donne visibilite + atomicite = impossiblite de donner la main a un autre thread sur le meme bloc synchro</p>
</div>
<div class="sect3">
<h4 id="_retoursur_le_bug_du_double_check_locking"><a class="anchor" href="#_retoursur_le_bug_du_double_check_locking"></a>Retoursur le bug du double check locking</h4>
<div class="paragraph">
<p>si on fait un retour sur le double check locking, on constate (cf image) qu il n y a pas de relation HB entre l operation de lecture et l operation d ecriture &#8658; pas de garantie de bien lire la valeur qui a ete ecrite</p>
</div>
<div class="paragraph">
<p>Où est exactement le problème?
lorsque l&#8217;on lit la valeur d&#8217;instance dans
if(instance != null) { return instance; }
on peut tres bien avoir une valeur non nulle alors que le constrcuteur est en train de s executer et n a pas fini (instance = new Service()*)
* je fais plusieurs operations
- malloc (reserver la memoire dont je vais avoir besoin pour l&#8217;objet)
- execution du constructeur
- copie du pointeur dans la variable instance</p>
</div>
<div class="paragraph">
<p>le malloc se fera tjrs en premier mais laquelle des 2 autres se fait en premier ?
si c&#8217;est l execution du constructuer &#8658; ok pas de souci
si c&#8217;est la copie du pointeur je retourne une instance vers une zone de la memoire dans laquelle le constructreur est encore en train de s executer &#8658; un objet corrompu</p>
</div>
<div class="paragraph">
<p>Bilan : ce pattern autorise l inejction dans l&#8217;application d objets non completmeent construits, d objets corrompus
Ce bug est un bug tres subtil qui tient de la notion et de la specification de lien HB</p>
</div>
<div class="paragraph">
<p>A partir de 2005, la generalisation des processeurs mutlicoeurs font que le modele de progrmamation concurrente evolue. &#8658; notion de Runnable et de Thread vont etre revues !</p>
</div>
<div class="paragraph">
<p>Problèmes posés par le pattern Thread/Runnable
Thread t = new Thread(task);
t.start();
1) coûteux : une fois sa tache terminee, on ne peut pas reutiliser le thread, il s&#8217;autodetruit ce qui est dommage car c&#8217;est une ressource de l&#8217;OS donc les requetes faites sur l&#8217;OS sont tres couteuses
2) laisse l&#8217;app creer des threads "a la demande" : si on est ds une appli qui cree enormement de threads, on peut etre amene a un pb de charge au niveau de la JVM et de notre app et meme de l&#8217;OS qui ne peut pas gerer un npmbre infini de threads</p>
</div>
<div class="paragraph">
<p>A partir de Java 5 (2004) on a un autre pattern = Executor</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_pattern_executorexecutorservice"><a class="anchor" href="#_pattern_executorexecutorservice"></a>Pattern Executor/ExecutorService</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Executor = réserve de threads construit sur un certain nombre de threads, les threas sont crees en meme temps que cet Executor et restent dispo drant toute la vie de cet Executor.
J&#8217;ai une tache, l&#8217;executor va fournir un thread existant pour l executer et une fois la tache terminee, je rends ce thread a la reserve des threads</p>
</div>
<div class="paragraph">
<p>Regle 2 pbs :
1) on recupere les threads
2) on n&#8217;autorise plus la création de threads "à la demande"</p>
</div>
<div class="sect2">
<h3 id="_création"><a class="anchor" href="#_création"></a>Création</h3>
<div class="paragraph">
<p>Executor &amp; ExecutorService = interfaces</p>
</div>
<div class="paragraph">
<p>classe factory Executors pour creer des instances :
Executors.newSingleThreadExecutor();
Executors.newFixedThreadPoolExecutor(int n);
comment choisir n
- ce que font les threads = nature de la tache
- nombre de coeurs dans le CPU</p>
</div>
<div class="paragraph">
<p>si on a des threads qui font essentiellemtn des traitements de calculs = qui ne sortent pas de la memoire, on regle le nombre de threads de notre reserve sur le nombre de coeurs du CPU (sur 8 coeurs prendre 6-7)</p>
</div>
<div class="paragraph">
<p>si on a des treads qui font bcp des ops entree sortie typiquement des lecteures ecritures sur le reseau ou sur le disque, nos threads vont peu utiliser le CPU car ils vont passer du temps a attendre &#8658; prendre + de threads que le nombre de coeurs</p>
</div>
</div>
<div class="sect2">
<h3 id="_soumettre_une_tache"><a class="anchor" href="#_soumettre_une_tache"></a>Soumettre une tache</h3>
<div class="paragraph">
<p>ExecutorService es = &#8230;&#8203;;
es.execute(runnable);
Runnable runnable = &#8230;&#8203;;</p>
</div>
</div>
<div class="sect2">
<h3 id="_modele_de_tache"><a class="anchor" href="#_modele_de_tache"></a>Modele de tache</h3>
<div class="paragraph">
<p>avant Java 5 : Runnable: void run() : on ne retourne rienm pas de param en arg et pas d exception a jeter
Inconvenients =
1) une tache ne peut pas retourner une valeur
2) si on fait une tache de lecture/ecriture sur reseau/disque et que cela se passe mal, l&#8217;exception de la tache ne peut pas etre remonte jusqu au thread qui effectue la tache &#8658; pas moyen de signaler que qqchose ne s est pas passe normalement</p>
</div>
<div class="paragraph">
<p>Callable&lt;V&gt; : V call() throws Exception;
Callable&lt;String&gt; c = () &#8594; "Bonjour";
es.submit(c); // equivalent de execute pour un runnable</p>
</div>
</div>
<div class="sect2">
<h3 id="_récupérer_le_résultat_dune_tâche_callable_au_travers_dun_future_pattern_callablefuture"><a class="anchor" href="#_récupérer_le_résultat_dune_tâche_callable_au_travers_dun_future_pattern_callablefuture"></a>Récupérer le résultat d&#8217;une tâche Callable au travers d&#8217;un Future : Pattern Callable/Future</h3>
<div class="paragraph">
<p>Future&lt;String&gt; future = es.submit(c); : modelise la transmission, la communication entre le thread qui a cree la tache et le thread qui va l&#8217;executer</p>
</div>
<div class="paragraph">
<p>ex: on a un thread Main qui fait
task =&#8230;&#8203;
future = es.submit(task); // va etre executer par un thread T2 (chaine de caracteres bonjour créée dans T2)</p>
</div>
<div class="paragraph">
<p>String s = future.get(); // methode get consitute un appel bloquant car bloque tant que la valeur n&#8217;est pas generee dans le thread de l ES
get(timeout) &#8594; exception a l issue du timeout
peut renvoyer une ExecutionException : supposons qu on lit une donnee sur le disque &#8658; IoException, future va wrapper cette exception dans ExecutionException avec comme root cause l&#8217;IoException</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_etats_dun_thread_transition_entre_ces_états"><a class="anchor" href="#_etats_dun_thread_transition_entre_ces_états"></a>Etats d&#8217;un Thread, transition entre ces états</h2>
<div class="sectionbody">
<div class="paragraph">
<p>NEW : creation du thread
RUNNABLE : en train d executer une tache
TERMINATED : fin d&#8217;execution de la tache
BLOCKED (synchronised) : a l entree d un bloc synchronise (il faut liberer la cle pour que le thread sorte de cet etat)
WAITING (wait()) : apres appel de wait() (il faut appeler notify oou notifyAll pour le liberer de cet etat)
TIMED_WAITING (sleep(timeout)) : sortir quand le timeout est ecoule ou si on appelle la methode interrupt</p>
</div>
<div class="sect2">
<h3 id="_arret_et_interruption_dun_thread"><a class="anchor" href="#_arret_et_interruption_dun_thread"></a>Arret et interruption d&#8217;un thread</h3>
<div class="paragraph">
<p>On ne peut pas arreter un thread.
stop() : interdit de l&#8217;appeler (dépréciée) !
&#8658; il faut interrupt() :
    signaler a un thread qu il faut s arreter d urgence
    mettre a true un booleen qui s appelle interrupt (on scrute regulierement la valeur de ce booleen pour voir s il faut mettre un terme a la tache en cours d execution)
    WARNING: marche pour un thread dans l etat RUNNABLE</p>
</div>
<div class="literalblock">
<div class="content">
<pre>pour WAITING, TIMED_WAITING : appeler interrupt() -&gt; jette InterruptedException</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>BLOCKED : "perdu" pas de noyen de les remettre en RUNNABLE SAUF si on lui rend la cle</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_arret_dun_es"><a class="anchor" href="#_arret_dun_es"></a>Arret d&#8217;un ES</h3>
<div class="paragraph">
<p>es.shutdown() // doit etre appele a la fin d une app
car les threads de l&#8217;ES ont daemon = false et si Main s arrete, les threads non daemon vont maintenir la JVM vivante &#8658; la machine Java continuera de s executer
- si des taches dans la file d&#8217;attente &#8594; executees
- nouvelles taches soumises &#8594; refusees
- taches en execution &#8594; vont etre executees jusqu au bout</p>
</div>
<div class="paragraph">
<p>es.shutdownNow() // taches retirees de la file d&#8217;attente, nouvelles refusees et en cours jusqu au bout</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_pattern_compare_and_swap_aux_variables_atomiques"><a class="anchor" href="#_pattern_compare_and_swap_aux_variables_atomiques"></a>Pattern Compare and Swap aux variables atomiques</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Prenons l&#8217;exemple d&#8217;un compteur.
On le fait avec la relation HB</p>
</div>
<div class="paragraph">
<p>public void increment() {
    synchronized(lock) {
        index++;
    }
}</p>
</div>
<div class="paragraph">
<p>public int getIndex() {
    synchronized(lock) {
        return index;
    }
}</p>
</div>
<div class="paragraph">
<p>le probleme avec les synchronized c est la performance et l&#8217;efficacite a cause de la requete sur l objet lock</p>
</div>
<div class="paragraph">
<p>Depuis Java 5 :
AtomicInteger
AtomicLong
AtomicReference</p>
</div>
<div class="paragraph">
<p>AtomicLong index = new AtomicLong(0L);
index.incrementAndGet();
index.get();</p>
</div>
<div class="paragraph">
<p>Differences entre les 2 ?</p>
</div>
<div class="ulist">
<ul>
<li>
<p>du point de vue formel, quasiment pas, j&#8217;incremente et je lis la valeur</p>
</li>
<li>
<p>du point de vue implementation, rien a voir :
incrementAndGet(); 1 seule instruction ASM = extrememet efficace
se base sur le CASing = Compare And Swap :
ca va aller regarder en memoire la valeur d index en supposant que la valeur d index c est la valeur precedente qui avait ete lu par ce meme thread.
ex: ce thread a fait sa derniere incrementation et qu il a trouve la valeur 5, il va commencer par regarder la memoire, si y a tjrs la valeur 5 il passe a la vlaeur 6 sans faire de synchro, il va juste en deduire qu uaucn autre thread n est venu dans son dos n est venu modifie la memoire
cette operation CAS (swaper la valeur 5 avec la valeur 6)</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_primitives_de_synchronisation_java_5"><a class="anchor" href="#_primitives_de_synchronisation_java_5"></a>Primitives de synchronisation (Java 5)</h4>
<div class="paragraph">
<p>rendent obsolete le mot cle symchronized</p>
</div>
<div class="sect4">
<h5 id="_lock"><a class="anchor" href="#_lock"></a>Lock</h5>
<div class="paragraph">
<div class="title">Semaphore</div>
<p>Lock lock = new ReentrantLock();
try {
    lock.lock();
} finally {
    lock.unlock();
}</p>
</div>
<div class="paragraph">
<p>apporte des fonctionnalites supplementaire par rapport au bloc synchronise
tryLock // si lock non dispo, le thread n ira pas dans la file d&#8217;attente et executera un code alternatif
tryLock(timeout) //</p>
</div>
<div class="sect5">
<h6 id="_comparaison_du_pattern_producerconsumer_avec_lock_et_condition"><a class="anchor" href="#_comparaison_du_pattern_producerconsumer_avec_lock_et_condition"></a>Comparaison du pattern producer/consumer avec Lock et Condition</h6>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
on ne peut utiliser wait()/notify() QUE dans des blocs synchronizés !
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Lock lock = new ReentrantLock();
Condition notEmpty = lock.newCondition();
Condition notFull = lock.newCondition();</p>
</div>
<div class="paragraph">
<p>try {
    lock.lock();
    while (isFull(buffer))
        notFull.await();
    buffer[index++] =&#8230;&#8203;;
    notEmpty.signal();
} finally {
    lock.unlock();
}</p>
</div>
<div class="paragraph">
<p>try {
    lock.lock();
    while (isEmpty(buffer))
        notEmpty.await();
    buffer[--index] =&#8230;&#8203;;
    notFull.signal();
} finally {
    lock.unlock();
}</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_readwritelock"><a class="anchor" href="#_readwritelock"></a>ReadWriteLock</h5>
<div class="paragraph">
<p>Map&lt;String, Object&gt; cache =&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>public void put(String key, Object o) {
    map.put(key, o);
}</p>
</div>
<div class="paragraph">
<p>public Object get(String key) {
    return map.get(key);
}</p>
</div>
<div class="paragraph">
<p>Prenons l&#8217;exemple d&#8217;un cache que l&#8217;on pourrait utiliser en entree dune BDD, ma chaine de caracteres = la cle primaire de l&#8217;objet et avant de chercher l&#8217;objet en BDD, je vais voir si je l ai pas deja vu et charge en memoire &#8658; chercher dans le cache plutot qu en BDD qui serait plus couteux
&#8658; j ai besoin d avoir la visilbite toutes les operations de type PUT doivent etre visibles du code qui est execute dans le get &#8658; blocs sychronises
ca a d autres consequences :  quand on fait un put() personne d autre ne pourra faire un put() OK
MAIS si on fait un get() personne d&#8217;autre ne pourra faire un get() au meme moment et ca c est pas ce que l&#8217;on veut, la synchronization m epehce de faire le // sur les operations de type get()
je ne veux pas de concurrence d acces en ecriture
je la veux en lecture car non dangereux
je veux la visibilite entre le get et le put</p>
</div>
<div class="paragraph">
<p>ReadWriteLock lock = new ReentrantReadWriteLock();
Lock readLock = lock.readLock();
Write writeLock = lock.writeLock();</p>
</div>
<div class="paragraph">
<p>Map&lt;String, Object&gt; cache =&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>public void put(String key, Object o) {
    try {
        // impose une exclusivite sur le bloc de code &#8658; aucun autre thread ne pourra executer map.put() et aucun autre thread ne pourra executer map.get()
        writeLock.lock();
        map.put(key, o);
    } finally {
        writeLock.unlock();
    }
}</p>
</div>
<div class="paragraph">
<p>public Object get(String key) {
    try {
        // n&#8217;impose pas d exclusivite sur le bloc qu il garde, en revanche il empeche l execution du bloc garde par le writeLock
        readLock.lock();
        return map.get(key);
    } finally {
        readLock.unlock();
    }
}</p>
</div>
<div class="paragraph">
<p>Bilan : l&#8217;objet ReadWriteLock permet une exclusivite sur les ecritures et de la concurrence d acces sur les lectures tout en conservant les liens HB necessaires entre les lectures et les ecritures</p>
</div>
</div>
<div class="sect4">
<h5 id="_semaphore"><a class="anchor" href="#_semaphore"></a>Semaphore</h5>
<div class="paragraph">
<p>Semaphore semaphore = new Semaphore(5);
5 = nombre de permis
agit comme un lock : lock autorise un thread dans un bloc de code particulier garde par ce lock
le semaphore ici 5 threads
try {
    sempahore.tryAcquire();
    &#8230;&#8203;
} finally {
    semamphore.release();
}</p>
</div>
<div class="paragraph">
<p>utile quand on veut garder un bloc de code et imposer un nombre maximal de threads pour executer ce bloc de code
historiquement, cree y a de nombres annees pour garder des ressources physiques tq des canaux de communication et qu on veut limiter le nombre de threads par canal.</p>
</div>
</div>
<div class="sect4">
<h5 id="_cyclicbarrier"><a class="anchor" href="#_cyclicbarrier"></a>CyclicBarrier</h5>
<div class="paragraph">
<p>CyclicBarrier barrier = new CyclicBarrier(4); // nombre de threads que cette barrier puisse gerer</p>
</div>
<div class="paragraph">
<p>ex: calcul des nombres premiers
Integer &#8594; primes
je divise mon nombre d entiers en 4 paquets et confier cahcun des paquets a une tâche</p>
</div>
<div class="paragraph">
<p>Callable&lt;List&lt;Integer&gt;&gt; task1 = () &#8594; {
    List&lt;Integer&gt; primes = findPrimes(&#8230;&#8203;);
    try {
        barrier.await();
    } catch(Exception e) {}
    return primes;
}
es.submit(task1);</p>
</div>
<div class="paragraph">
<p>await() est bloquante, va compter le nombre de fois qu elle a ete appele par les differents threads et quand elle aura ete  appele 4 fois await() de barrier, cette methode va rendre la main (la barriere va s ouvrir et se fermer a nouveau) et le code va continuer a s executer. je recupere le resultat des 4 taches et j en fais un global</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
4 doit etre &gt;= au nombre de threads de l&#8217;ES.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_countdownlatch"><a class="anchor" href="#_countdownlatch"></a>CountDownLatch</h5>
<div class="paragraph">
<p>fonctionne un peu comme la barriere cyclique
on va le creer sur un nombre et a chaque fois qu on appellera une certaine methode de cet objet on le decremente
a 0 le latch va souvrir et laisser passer le thread qui est en attente dessus</p>
</div>
<div class="paragraph">
<p>use case : lancement initial des applications
Prenoms l&#8217;exemple d une application qui doit lancer un certain nombre de services a initialiser avant qu elle puisse fonctionner proprement
3 services : mailService, diskService, dbService</p>
</div>
<div class="paragraph">
<p>public class ServiceLauncher implements Runnable {
    private CountDownLatch latch;
    private Service service;
    public ServiceLauncher(&#8230;&#8203;) {}
    public void run() {
        service.init();
        latch.countDown(); // on decremente une fois l&#8217;initialisation du service fini
    }
}</p>
</div>
<div class="paragraph">
<p>ExecutorService es = new ES(4);
CountDownLatch latch = new CDL(3);
mailLauncher = new ServiceLauncher(mailService, latch);</p>
</div>
<div class="paragraph">
<p>es.execute(mailLauncher);
es.execute(diskLauncher);
es.execute(dbLauncher);
latch.await(); // ajout timeout possible
application.start();</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_collections_concurrentes"><a class="anchor" href="#_collections_concurrentes"></a>Collections Concurrentes</h4>
<div class="ulist">
<ul>
<li>
<p>CopyOnWriteArrayList</p>
</li>
<li>
<p>BlockingQueue</p>
</li>
<li>
<p>ConcurrentHashMap
ont la prop d etre thread safe elles peuvent etre utilise dans un contexte de programmatin conurrente avec toutes les garanties de perf visiblilte et sychroniation que l on attend.</p>
</li>
<li>
<p>CopyOnWriteArrayList : tableau en memoire encapsule a l interieur d un objet de type ArrayList
(cf image)
ce tableau est pointé par un pointeur particulier
quandje fais une ope de type modif (add, remove, set) : on copie d&#8217;abord le tableau en interne avec l element a ajouter a la fin et de facon atomique le pointeur pointe vers la nouvelle version du tableau &#8658; la duplication du tableau est tres couteuse
le tableau une fois en memoire n est jamais modifie = immutable &#8658; je peux le lire gratuitement, pas besoin de synchro car je sais que ce que je suis en train de lire ne pourra jamais etre modifie par aucun thread.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>utile quand on a peu d ecriture et bcp de lecture</p>
</div>
</div>
<div class="sect2">
<h3 id="_organisation_de_lapi_des_files_dattente_concurrentes_en_java_5"><a class="anchor" href="#_organisation_de_lapi_des_files_dattente_concurrentes_en_java_5"></a>Organisation de l&#8217;API des files d&#8217;attente concurrentes en Java 5</h3>
<div class="paragraph">
<p>LIFO (Last In First Out)
FIFO (First In First Out)
2 implementations non concurrentes classqiues modelisees par les interfaces Queue et Deque (extension de Queue, Double ended Queue = je peuxacceder a cette file d attente des 2 extremites a la fois pour ajouter regarder retirer des elements) :
interfaces concurrentes
BlockingQueue
    implemtnations : ArrayBlockingQueue file d attente synchronisee sur un tableau (taille fixee a la construction)
    LinkedBlockingQueue sur une liste chainee
    (taille fixee ou non fixee a la construction)</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
quand on fait dla concurrence pas forcement une bonne idee de fixer une taille a l infini car si j ai trop de producers par rapport au consommateurs je peux exploser la mempire de mon app et de mon serveur
    SynchronousBlockingQueue (taille 0)
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>BlockingDeque
    implementation : LinkedBlockingDeque</p>
</div>
<div class="ulist">
<ul>
<li>
<p>ConcurrentLinkedQueue : implementation de Queue qui n implemente pas BlockingQueue (taille non fixee)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Comportements de BlockingQueue lorsque la file d&#8217;attente est vide ou pleine</p>
</div>
<div class="paragraph">
<p>Ces files d attentes synchronisees nous servent a implementer le pattern producer/consumer et on tombe dans les meme probleems que precedemment avec les lock, wait notify &#8658; saturation et vide</p>
</div>
<div class="ulist">
<ul>
<li>
<p>saturation : ajout d un element dans ine strucrure pleine</p>
</li>
<li>
<p>file d attente vide : retirer un element dans une structure vide</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>1) retourune une valeur particuliere (boolean false si l ajout n a pas marche)
2) bloquer jusqu a ce qu&#8217;une case se libere
3) bloquer avec un timeout
4) jeter une exception</p>
</div>
<div class="paragraph">
<p>SynchronousBlockingQueue : n a pas de buffer interne
un producer cherche a mettre eun elt dans cette file d attente il va bloquer avec un timeout parce que pas de buffer pour stocker cet elt, il sera consomme au momemt ou un consommateur arrive pour le prendre (analogie avec une poignee de main)
l elt passe directment du proucer au consumer sans  passer par un buffer &#8658; tres performant quand on a bcp de producteurs et de consumer et qu on a un equilibrage entre la vitesse de production et de consommation &#8658; le systeme est tres peu bloque</p>
</div>
<div class="ulist">
<ul>
<li>
<p>ConcurrentHashMap
2 versions
JDK5-7 : dimensionnee pour 16 threads
JDK 8 : bcp + de threads : entierement refaite et expose tout un tas de fonctionnalites de traitemtns de donnees en // directement a l interieru de  la table de hacahge qui sont extrememnts perfoannts
implemente ConcurrentMap
utile pour faire des caches (put/get)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>autre implementation ConcurrenSkipListMap : liste chainee  indexee par des objets qui sont Comparables
peut etre utilisee en concurrence sans utiliser de synchro
tout est construit sur des AtonicReference (CAS)</p>
</div>
<div class="paragraph">
<p>BILAN :
* Runnable avec la facon de creer des taches et de lancer des threads un par un en confiant nos taches a ces threads
* Executor : pattern qui remplace Runnable avec des Runnable et des Callable,
* Future : communiquer des donnees entre le thread qui fait le traitement a l inteirue de l&#8217;ES et celui qui lance le traitemtn
* Differentes facons de Synchronizer le code
* Execution exclusive de blocs de code = atomicite
* Problemes de visibilite : entre les modifs faites par un thread et lecture dans un autre thread, problemes amplifies par l arrivee des processeurs multicoeurs etant donne qu une meme variable peut vivre dans plusieurs endroits physiques disponsibles
* Primitives de synchro amenés par Java 5 :
Lock, ReadWriteLock, Semaphore, CyclicBarrier, CountDownLatch
* Collections concurrentes</p>
</div>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<footer class="footer">
  <p>This page was built using the Antora default UI.</p>
  <p>The source code for this UI is licensed under the terms of the MPL-2.0 license.</p>
</footer>
<script src="../../../_/js/site.js"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
  </body>
</html>
